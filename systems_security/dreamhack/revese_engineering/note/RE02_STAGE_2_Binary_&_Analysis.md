# STAGE 2 Binary & Analysis

# Background: Binary

## 1. 서론

### 서론

---

- 어떤 대상에게 명령을 내리려면, 그 대상과의 소통에 사용할 언어가 필요
    - 컴퓨터 과학자들은 컴퓨터에 명령을 내리기 위해 **기계어(Machine Language)**라는 컴퓨터의 언어를 정의
    - 필요한 연산을 컴퓨터가 대신하도록 기계어로 명령을 내렸음
- 기계어는 0과 1로 이루어져 있어 사람이 이해하기 어려우, 이를 이용해서 컴퓨터에 명령을 내리는 것은 비효율적
    - 컴퓨터 과학자들은 사람이 이해하기 쉬운 새로운 언어로 **어셈블리어(Assembly Language)**를 고안했고, 이를 기계어로 번역해주는 **어셈블러(Assembler)**를 개발
- 어셈블리어는 기계어에 비하면 효율적이었으나, 규모가 큰 프로그램을 개발하기에는 역부족
    - C, C++ 등을 비롯하여 어셈블리어보다 더욱 사람이 이해하기 쉬운 언어들을 만들어졌고, 이들을 기계어로 번역해주는 **컴파일러(Compiler)** 역시 개발됨
    - 이 언어들은 프로그램 개발의 효율을 극대화해주었으며 현재까지도 널리 사용
- 프로그래밍에 사용하는 언어 중, 사람이 이해하기 쉬운 언어를 **고급 언어(High-Level Language)**라고 부르며, 그 반대의 언어를 **저급 언어(Low-Level Language)**라고 부름
    - C, C++이 전자에, 기계어나 어셈블리어가 후자에 속함
    - 초기에는 컴파일 이론 및 관련된 기술들이 미흡하 고급 언어로 개발하는 것이 만족스럽지 않을 때가 있었으나, 현대에는 이런 단점이 거의 보완
    - 생산성의 측면에서, 고급 언어가 저급 언어보다 압도적으로 효율적이기 때문에 이제는 특별한 경우를 제외하고는 저급 언어로 프로그램을 개발하지 않음

## 2. 프로그램과 컴파일

### 프로그램

---

- **프로그램(Program)**은 연산 장치가 수행해야 하는 동작을 정의한 일종의 문서
    - 프로그램을 연산 장치에 전달하면, CPU는 적혀있는 명령들을 처리하여 프로그래머가 의도한 동작을 수행
    - 사용자가 정의한 프로그램을 해석하여 명령어를 처리할 수 있는 연산 장치를 *programmable*하다고 하는데, 현대의 컴퓨터가 대표적인 *programmable* 연산 장치이고, 일반 계산기는 대표적인 *non-programmable* 연산 장치
- 과거에는 프로그램을 내부 저장 장치에 저장할 수 없어서 사람이 전선을 연결하여 컴퓨터에 전달하거나, **천공 카드(Punched card)**에 프로그램을 기록하여 재사용하는 방식을 사용
    - 전자의 방식을 사용한 컴퓨터가 에니악(ENIAC)인데, 프로그램이 바뀔 때마다 배선을 재배치해야 했으므로 매우 비효율적이었고, 크기가 큰 프로그램을 사용하기도 어려웠음
- 이런 단점을 해결한 *Stored-Program Computer*가 1950년경에 최초로 상용화
    - 이 컴퓨터는 프로그램을 메모리에 전자적으로, 또는 광학적으로 저장할 수 있었는데, 기존의 컴퓨터들보다 월등히 많은 프로그램을 저장할 수 있었으며, 저장된 프로그램을 사용하는 것도 간편
    - 이 후 컴퓨터의 대부분이 *Stored-Program Computer*의 형태로 개발
- 소프트웨어 개발자, 해커 등 많은 정보 분야의 엔지니어들이 프로그램을 **바이너리(Binary)**라고 부르곤 하는데, 이는 *Stored-Program Computer*에서 프로그램이 저장 장치에 이진(Binary) 형태로 저장되기 때문
    - 텍스트가 아닌 다른 데이터들도 바이너리라고 불리긴 하지만, 많은 경우에 바이너리라고 하면 프로그램을 의미

### 컴파일러와 인터프리터

---

- **프로그래밍 언어(Programming Language)**는 프로그램을 개발하기 위해 사용하는 언어
- CPU가 수행해야 할 명령들을 프로그래밍 언어로 작성한 것을 **소스 코드(Source Code)**라고 하는데, 이를 컴퓨터가 이해할 수 있는 기계어의 형식으로 번역하는 것을 컴파일(Compile)이라고 함
    - 컴파일을 해주는 소프트웨어는 **컴파일러(Compiler)**라 불리는데, 대표적으로 GCC, Clang, MSVC 등이 있음
    - 한번 컴파일 되면 결과물이 프로그램으로 남기 때문에 언제든지 이를 실행하여 같은 명령을 처리하게 할 수 있음
- 모든 언어가 컴파일을 필요로 하는 것은 아님
    - 대표적으로 Python, Javascript 등의 언어는 컴파일을 필요로 하지 않음
    - 이 언어들은 사용자의 입력, 또는 사용자가 작성한 스크립트를 그때 그때 번역하여 CPU에 전달
    - 이 동작이 통역과 비슷하기 때문에 **인터프리팅(Interpreting)**이라고 불리며, 마찬가지로 이를 처리해주는 프로그램을 **인터프리터(Interpreter)**라고 함
- 컴파일은 배경 지식이 없는 사람이 책을 읽을 수 있도록 배경 지식을 엮고, 번역하여 하나의 번역본을 만드는 과정으로, 그리고 인터프리팅은 동시 통역사를 거쳐 대화하는 것으로 비유하여 이해할 수 있음
    - 전자는 결과물이 남아서 언제든 다시 읽어볼 수 있지만 한 번 번역하는데 시간이 많이 필요하고, 후자는 상대방과 빠르게 의사소통할 수 있지만, 같은 이야기를 하더라도 매번 통역사를 거쳐야 한다는 단점이 있음

### 컴파일 과정

---

```c
/*
 * Name: S2_00_add.c
 */

#include "add.h"

#define HI 3

int add(int a, int b)
{
	return a + b + HI;
}
```

```c
/*
 * Name: S2_01_add.h
 */

int add(int a, int b);
```

- C언어로 작성된 코드는 일반적으로 **전처리(Preprocess), 컴파일(Compile), 어셈블(Assemble), 링크(Link)**의 과정을 거쳐 바이너리로 번역
- **컴파일(Compile)**의 정확한 의미는 어떤 언어로 작성된 소스 코드(Source Code)를 다른 언어의 목적 코드(Object Code)로 번역하는 것
    - 이런 맥락에서, 소스 코드를 어셈블리어로, 또는 소스 코드를 기계어로 번역하는 것 모두 컴파일이라고 볼 수 있음

### 전처리

---

- **전처리(Preprocessing)**는 컴파일러가 소스 코드를 어셈블리어로 컴파일하기 전에, 필요한 형식으로 가공하는 과정
- 언어마다 조금씩 다르지만, 컴파일 언어의 대부분은 다음의 전처리 과정을 거침
    1. 주석 제거
        1. 주석은 개발자가 자신과 개발자들의 코드 이해를 돕기 위해 작성하는 메모
        2. 주석은 프로그램의 동작과 상관이 없으므로 전처리 단계에서 모두 제거
    2. 매크로 치환
        1. `#define`으로 정의한 매크로는 자주 쓰이는 코드나 상수 값을 단어로 정의한 것
        2. 전처리 과정에서 매크로의 이름은 값으로 치환
    3. 파일 병합
        1. 일반적인 프로그램은 여러 개의 소스와 헤더 파일로 이루어져 있음
        2. 컴파일러는 이를 따로 컴파일해 합치기도 하지만, 어떠한 경우는 전처리 단계에서 파일을 합치고 컴파일하기도 함
- gcc에서는 -E 옵션을 사용하여 소스 코드의 전처리 결과를 확인할 수 있음
    - `$ gcc -E S2_00_add.c > S2_03_add.i`
    - [S2_03_add.i](../src/S2_02_add.i)

### 컴파일

---

```c
/*
 * Name: S2_03_opt.c
 * Compile: gcc -o S2_03_opt S2_03_opt.c -O2
 */

#include <stdio.h>

int main(void)
{
	int x = 0;
	int i;
	for (i = 0; i < 100; i++)
		x += i;
	printf("%d", x);
	return 0;
}
```

- **컴파일(Compile)**은 C로 작성된 소스 코드를 어셈블리어로 번역하는 것
    - 이 과정에서 컴파일러는 소스 코드의 문법을 검사하는데, 코드에 문법적 오류가 있다면 컴파일을 멈추고 에러를 출력
- 컴파일러는 코드를 번역할 때, 몇몇 조건을 만족하면 최적화 기술을 적용하여 효율적인 어셈블리 코드를 생성
    - gcc에서는 `-O -O0 -O1 -O2 -O3 -Os -Ofast -Og` 등의 옵션을 사용하여 최적화를 적용할 수 있음
- `SP_03_opt.c`를 최적화하여 컴파일하면, 컴파일러는 반복문을 어셈블리어로 옮기는 것이 아니라, 반복문의 결과로 `x`가 가질 값을 직접 계산하여, 이를 대입하는 코드를 생성
    - 이를 통해 사용자가 작성한 소스 코드와 연산 결과는 같으면서도, 최적화를 적용하지 않았을 때보다 더 짧고, 실행 시간도 단축되는 어셈블리 코드가 만들어지게 됨
- `$ gcc -S S2_02_add.i -o S2_04_add.s`
- [S2_04_add.s](../src/S2_04_add.s)

### 어셈블

---

- **어셈블(Assemble)**은 컴파일로 생성된 어셈블리어 코드를 ELF형식의 **목적 파일(Object file)**로 변환하는 과정
    - ELF는 리눅스의 실행 파일 형식
    - 윈도우에서 어셈블한다면 목적 파일은 PE형식을 갖게 됨
- 목적 파일로 변환되고 나면 어셈블리 코드가 기계어로 번역되므로 더 이상 사람이 해석하기 어려워짐
- gcc의 “-c” 옵션을 통해 `S2_04_add.s`를 목적 파일로 변환하고, 결과로 나온 파일을 16진수로 출력
    - 읽을 수 있는 문자열 중 코드로 보이는 것은 없음
    - `$ gcc -c S2_04_add.s -o S2_05_add.o`
    - `$ file S2_05_add.o`
    - `$ hexdump -C S2_05_add.o`
    - [S2_05_add.o](../src/S2_05_add.o)

### 링크

---

```c
/*
 * Name: S2_06_hello-world.c
 * Compile: gcc -o S2_06_hello-world S2_06_hello-world.c
 */

#include <stdio.h>

int main(void)
{
	printf("Hello, world!");
}
```

- **링크(Link)**는 여러 목적 파일들을 연결하여 실행 가능한 바이너리로 만드는 과정
    - 위 코드에서 `printf`함수를 호출하지만, `printf` 함수의 정의는 `S2_06_hello-world.c`에 없으며, `libc`라는 공유 라이브러리에 존재
    - `libc`는 gcc의 기본 라이브러리 경로에 있는데, 링커는 바이너리가 `printf`를 호출하면 `libc`의 함수가 실행될 수 있도록 연결
    - 링크를 거치고 나면 실행할 수 있는 프로그램이 완성
- `S2_05_add.o`를 링크하는 명령어
    - 링크 과정에서 링커는 `main`함수를 찾는데, `add`의 소스 코드에는 `main`함수의 정의가 없으므로 에러가 발생할 수 있음
    - 이를 방지하기 위해 `--unresolved-symbols`를 컴파일 옵션에 추가
    - `$ gcc S2_05_add.o -o S2_07_add -Xlinker --unresolved-symbols=ignore-in-object-files`
    - `$ file S2_07_add`

## 3. 디스어셈블과 디컴파일

### 디스어셈블

---

- 바이너리를 분석하려면 바이너리를 읽을 수 있어야 하지만 컴파일된 프로그램의 코드는 기계어로 작성되어 있으므로 이를 그 자체로 이해하기는 매우 어려움
    - 그래서 분석가들은 이를 어셈블리어로 재번역
    - 이 과정은 앞서 살펴본 어셈블의 역과정이므로 **디스어셈블(Disassemble)**이라고 부름
- 다음 명령어로 쉽게 디스어셈블된 결과를 확인할 수 있음
    - `$ objdump -d ./S2_07_add -M intel`

### 디컴파일

---

- 디스어셈블 기술의 등장으로 예전보다는 바이너리를 분석하기 쉬워졌지만, 여전히 규모가 큰 바이너리의 동작을 어셈블리 코드만으로 이해하기는 어려움
    - 리버스 엔지니어들은 어셈블리어보다 고급 언어로 바이너리를 번역하는 **디컴파일러(Decompiler)**를 개발
- 어셈블리어와 기계어는 거의 일대일로 대응되어서 오차 없는 디스어셈블러를 개발할 수 있었지만, 고급 언어와 어셈블리어 사이에는 이런 대응 관계가 없었음
    - 또한, 코드를 작성할 때 사용했던 변수나 함수의 이름 등은 컴파일 과정에서 전부 사라지고, 코드의 일부분은 최적화와 같은 이유로 컴파일러에 의해 완전히 변형되기도 함
- 이런 어려움으로 인해 디컴파일러는 일반적으로 바이너리의 소스 코드와 동일한 코드를 생성하지는 못함
    - 그러나, 이 오차가 바이너리의 동작을 왜곡하지는 않으며, 디스어셈블러를 사용하는 것 보다 압도적으로 분석 효율을 높여주기 때문에, 디컴파일러를 사용할 수 있다면 반드시 디컴파일러를 사용하는 것이 유리
    - 특히 최근에는 Hex Rays, Ghidra를 비롯한 뛰어난 디컴파일러들이 개발되어서 분석의 효율을 더욱 높여주고 있음
    - 무료이면서도 성능이 뛰어난 **IDA Freeware**를 사용

# Background: Static Analysis vs. Dynamic Analysis

## 1. 서론

### 서론

---

- 소프트웨어를 분석할 때는 일반적으로 큰 구조를 먼저 관찰
    - 그러나 이것만으로 소프트웨어의 실제 동작을 알기 어려울 때가 많음
    - 그럴 때는 실제로 프로그램을 실행해보며 동작을 관찰해볼 수 있음
    - 그리고 더욱 자세한 분석이 필요할 때는 다시 여러 수단을 동원하여 특정 부분을 세밀하게 관찰
- 리버스 엔지니어링에서는 소프트웨어를 분석하기 위해 사용하는 분석 방법들을 크게 **정적 분석(Static Analysis)**과 **동적 분석(Dynamic Analysis)**으로 구분
    - 정적 분석은 외적인 관찰만을 통해 정보를 알아내는 것을 의미하며, 동적 분석은 실행을 통해 동작을 분석하는 것을 의미

## 2. 정적 분석

### 정적 분석

---

- **정적 분석(Static Analysis)**은 프로그램을 실행시키지 않고 분석하는 방법
- 정적 분석의 장점
    - 정적 분석을 사용하면 프로그램의 전체 구조를 파악하기 쉬움
        - 정적 분석 도구들은 프로그램의 여러 정보를 살펴볼 수 있도록 도움을 주는데, 프로그램이 어떤 함수로 구성됐고 함수들은 서로 어떤 호출 관계를 갖는지, 어떤 API를 사용하고 어떤 문자열을 포함하는지 등을 종합적으로 살펴볼 수 있음
    - 분석 환경의 제약에서도 비교적 자유로움
        - 안드로이드의 apk 파일은 별도의 소프트웨어를 사용하지 않는 한 윈도우 시스템에서 실행할 수 없음
        - 따라서 실행을 전제로 하는 동적 분석을 윈도우 환경에서 apk를 대상으로 하기는 다소 번거로움
        - 하지만 정적 분석은 프로그램을 실행하지 않아도 되므로 분석을 지원하는 적절한 도구만 갖춘다면 시도할 수 있음
    - 바이러스와 같은 악성 프로그램의 위협으로부터 안전
        - 만약 바이러스를 동적 분석할 경우, 바이러스를 실제로 실행해야 하므로 자신의 컴퓨터가 감염될 우려가 있음
        - 정적 분석은 프로그램을 실행하지 않고 분석하므로 이런 걱정을 하지 않아도 됨
- 정적 분석의 단점
    - 정적 분석은 프로그램에 난독화(Obfuscation)가 적용되면 분석이 매우 어려워짐
        - 소프트웨어를 리버스 엔지니어링으로부터 보호하기 위해 난독화 기법을 적용
        - 난독화가 적용되면 프로그램의 코드가 심하게 변형돼서 이를 읽고, 실행 흐름을 파악하기가 어려워짐
        - 해제(Deobfuscation)하기 위한 여러 연구가 진행되고 있지만, 여전히 많은 상용 난독화 서비스들을 무력화하는 방법은 알려지지 않음
    - 정적 분석만으로는 다양한 동적 요소를 고려하기 어려움
        - 프로그램은 실행 중에 영향을 주고 받는 여러 함수로 구성
        - A라는 함수가 B라는 함수에 들어가는 인자를 결정할 수도 있고, A와 B가 서로 같은 전역변수를 공유할 수도 있음
        - 어떤 함수가 특정 시점에 정확히 어떤 인자와 어떤 전역 변수를 가지고 실행될지는 정적으로 알기 어려움

## 3. 동적 분석

### 동적 분석

---

- **동적 분석(Dynamic Analysis)**은 프로그램을 실행시키면서 분석하는 방법
- 동적 분석의 장점
    - 동적 분석을 활용하면 코드를 자세히 분석해보지 않고도 프로그램의 개략적인 동작을 파악할 수 있음
    - 동적 분석은 어떤 입력에 대한 개별 함수 또는 프로그램의 출력을 빠르게 확인할 수 있으므로, 이 출력 값들을 기반으로 동작을 추론해 볼 수 있음
        - 예를 들어 md5라는 복잡한 알고리즘을 수행하는 함수가 있을 때, 정적으로만 분석하여 이 함수를 파악하는 것은 어려울 수 있음
        - 동적 분석으로는 어떤 입력 값을 넣고 결과 값이 md5 알고리즘의 결과 값과 같은지 비교하여 해당 함수가 md5 함수 인지를 쉽게 판단할 수 있음
- 동적 분석의 단점
    - 동적 분석의 단점은 분석 환경을 구축하기 어려울 수 있음
        - 동적 분석은 프로그램을 실행하면서 분석하는 것이므로, 프로그램을 실행하지 못하면 동적 분석을 진행할 수 없음
        - 그래서 다른 환경의 프로그램을 동적 분석할 때에는 가상 머신을 구축하거나 프로그램을 실행할 수 있는 장치를 구매해야 하는데, 이 과정이 대상에 따라 매우 번거롭고 어려울 수 있음
    - '난독화'처럼 동적 분석에 대해서도 이를 어렵게 하는 여러 기법이 개발되어 있음
        - 그 중 대표적인 것이 동적 분석의 일종인 디버깅을 방해하는 **안티 디버깅(Anti Debugging)**